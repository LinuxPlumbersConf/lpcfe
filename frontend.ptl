from quixote.directory import Directory, export, subdir
from quixote import get_request, get_response
from quixote.form import *
import datetime

import auth, page, bbb, config, indico

#
# Simulated times to start with.
#
def current_time():
    now = datetime.datetime.now()
    tz = datetime.timezone(datetime.timedelta(hours = config.SERVER_TZOFFSET))
    begin = datetime.datetime(2020, 8, 24, now.hour, now.minute, 0, tzinfo = tz)
    begin += datetime.timedelta(days = now.weekday() % 5)
    return begin

#
# Show this many minutes of upcoming sessions.
#
minutes = 240

class frontend(Directory):

    @export(name='')
    def index [html] (self):
        user = self.logged_in()
        if user:
            self.front_page(user)
        else:
            self.login_form()

    def front_page [html] (self, user):
        page.header('/', 'Welcome %s!' % (user.name), user.is_admin())
        self.main_text()
        page.end_text_area()
        self.render_schedule(current_time(), minutes)
        if user.is_admin():
            self.time_selector(current_time())
        page.trailer()

    def main_text [html] (self):
        '''This is the entry portal for the Linux Plumbers Conference 2020
           meeting rooms.  Look below for the list of what is happening
           currently.
           <p>
           <b>NOTE</b>: This system is currently running on a simulated time that
           passes repeatedly over the 2020 schedule.  The current time is %s.
           Times displayed below
           have been further offset to what we think is your time zone, which differs
           from UTC by %d minutes.
           ''' % (current_time().strftime(str('%Y-%m-%d %H:%M')), user_tz_offset())

    def time_selector(self, when):
        return time_selector_widget(when.weekday(), when.hour).render()

    @export
    def fake_time [html] (self):
        weekday, hour = time_selector_widget(0, 0).parse()
        page.header('/', 'LPC timetable at a fake time')
        tz = datetime.timezone(datetime.timedelta(hours = config.SERVER_TZOFFSET))
        begin = datetime.datetime(2020, 8, 24, 0, 0, 0, tzinfo = tz)
        begin += datetime.timedelta(days = weekday)
        begin += datetime.timedelta(hours = hour)
        '''This is the timetable rendered as if it were %s on the server.
        ''' % (begin.strftime(str('%Y-%m-%d %H:%M')))
        page.end_text_area()
        self.render_schedule(begin, minutes)
        self.time_selector(begin)
        page.trailer()


    @export
    def logout(self):
        response = get_response()
        response.expire_cookie('session')
        return response.redirect(config.SITE_URL)

    @export
    def stylesheet(self):
        response = get_response()
        response.set_header('content-type', 'text/css; charset=utf-8')
        response.cache = 600
        return page.CSS()
    #
    # Return the logged-in user, if any.
    #
    def logged_in(self):
        request = get_request()
        cookie = request.get_cookie('session')
        if not cookie:
            return None
        return auth.validate_cookie(cookie)

    def login_form [html] (self, message = None, email = ''):
        page.header('/', 'Please log in to continue', menu = False)
        insert_tz_js()
        '''Please login with the email address you used to register to LPC 2020.
           You need to enter your Registration Confirmation Number. That
           information is found in your confirmation email titled
           "Registration Confirmed - Linux Plumbers Conference 2020".
           <p>
           '''
        if message:
            '<b>' + message + '</b><p>\n'
        '<blockquote>\n'
        LoginForm(email = email).render('/login')
        '</blockquote>\n'
        '''<h4>Having trouble?</h4>
           <p>
           Please contact <tt>helpdesk@linuxplumbersconf.org</tt> for assistance
           accessing the conference site.
           '''
        page.trailer()

    @export
    def login (self):
        email, password = LoginForm().parse()
        if not (email and password):
            return self.login_form('Please fill in both fields', email = email)
        u = auth.check_password(email, password)
        if not u:
            return self.login_form('Unknown email or invalid password',
                                   email = email)
        #
        # OK, they've convinced us that they are for real.  Let's fix
        # them up with a session cookie and give them the real page.
        #
        cookie = auth.make_cookie(u)
        response = get_response()
        response.set_cookie('session', cookie)
        return response.redirect(config.SITE_URL)

    #
    # Moderator's server information page.
    #
    @export
    def status [html] (self):
        user = self.logged_in()
        if (not user) or (not user.is_admin()):
            get_response().redirect(config.SITE_URL)
        page.header('/status', 'Server and room status', True)
        self.list_servers()
        '<br clear="all">\n'
        self.list_rooms()
        page.trailer()

    def list_servers [html] (self):
        '<h4>Server status</h4>'
        '<dl>\n'
        '''<blockquote>
           <table class="OddEven">
           <tr><th>Server</th><th>status</th><th>Rooms</th><th>People</th></tr>
           '''
        for server in bbb.all_servers():
            meetings = bbb.status(server)
            if meetings is None:
                '<tr><td>%s</td><td>DOWN</td><td></td><td></td></tr>\n' % (server)
                continue
            nrooms = len(meetings)
            npeople = 0
            for m in meetings:
                npeople += int(m['people'])
            '<tr><td>%s</td><td>UP</td><td>%d</td><td>%d</td></tr>\n' % \
                        (server, nrooms, npeople)
        '</table></blockquote>\n'
    #
    # Room management
    #
    def list_rooms [html] (self):
        '''<h4>Room status</h4>
           <p>
           <blockquote>
           <table class="OddEven">
           <tr><th>Room</th>
               <th>Server</th>
               <th>Type</th>
               <th>Status</th>
               <th>People</th>
               <th>Listen</th>
               <th>Video</th>
               <th>Moderators</th>
               <th></th></tr>
           '''
        for room in bbb.all_rooms():
            status = bbb.room_status(room)
            '<tr><td>%s</td><td>%s</td><td>%s</td>' % (room, status['server'],
                                                       status['type'])
            if status['running']:
                '''<td>RUNNING</td>
                   <td align=right>%s</td><td align=right>%s</td>
                   <td align=right>%s</td>
                   <td>%s</td><td>''' % (status['people'], status['listeners'],
                                         status['video'], status['moderators'])
                room_join_button(room)
                '</td></tr>\n'
            else:
                '''<td>CLOSED</td>
                   <td></td><td></td><td></td><td></td><td>'''
                room_start_button(room)
                '</td></tr>\n'
        '</table></blockquote>\n'

    # Note this isn't currently used
    @export
    def start_room(self):
        response = get_response()
        user = self.logged_in()
        if (not user) or (not user.is_moderator()):
            return response.redirect(config.SITE_URL)
        room = HiddenWidget('room', '').parse()
        bbb.start_room(room)
        url = bbb.join_room_url(user.name, room, user.is_moderator())
        return response.redirect(url)

    @export
    def join_room(self):
        response = get_response()
        user = self.logged_in()
        if not user:
            return response.redirect(config.SITE_URL) # No fast ones here
        room = HiddenWidget('room', '').parse()
        status = bbb.room_status(room)
        #
        # Policy: let any user start a room if they have access to
        # a "join" button.
        #
        if not status['running']:
            bbb.start_room(room)
#            return self.room_closed(room)
        url = bbb.join_room_url(user.name, room, user.is_moderator())
        return response.redirect(url)

    #
    # This is not currently used.
    #
    def room_closed [html] (self, room):
        page.header('/', 'Room closed', False)
        '''The room you are trying to join has not yet been opened for
           general access.  Please accept our apologies for the inconvenience
           and retry shortly.
           <p>
           <blockquote>
           '''
        room_join_button(room, button_text = 'Retry room ' + room)
        '</blockquote>\n'
    #
    # A first shot at rendering a schedule.
    #
    def render_schedule [html] (self, begin, minutes):
        ttable = indico.get_timetable(begin, minutes)
        if len(ttable) == 0:
            '''<p>
               <b>NOTE</b>: there are no sessions underway at the current
               time.
               '''
            restart = indico.find_restart_time(begin)
            if not restart:
                'In fact, the event appears to be over.\n'
                return
            '''The conference will restart at %s with the sessions
               shown below.
               ''' % (offset_time(restart).strftime(str('%Y-%m-%d %H:%M')))
            ttable = indico.get_timetable(restart, minutes)
        tracks = sorted(ttable.keys())
        rows = self.generate_rows(ttable, tracks, begin, minutes)
        self.render_rows(begin, minutes, rows)

    def generate_rows(self, ttable, tracks, begin, minutes):
        #
        # Step 1; find all of our start times; those will become the
        # rows of our schedule table.
        #
        starts = { }
        for track in tracks:
            for item in ttable[track]:
                #
                # When does this one start, in minutes since the
                # beginning of our window?
                #
                offset = (item.begin - begin).total_seconds()
                if offset < 0: # session begins before window
                    offset = 0
                else:
                    offset //= 60
                #
                # Store all room events starting at this time.
                #
                try:
                    roominfo = starts[offset]
                except KeyError:
                    starts[offset] = roominfo = { }
                roominfo[track] = item
        rowtimes = sorted(starts.keys())
        #
        # Now figure out what the contents of each row will be.  Our choices
        # are:
        #	- An entry begins here
        #	- A "skip" - an entry continues and we need no entry
        #	- Blank - nothing happening.
        #
        openitems = { }
        firstrow = [ room_entry('') ]
        firstrow.extend([ room_entry(track) for track in tracks ])
        rows = [ firstrow ]
        has_join_button = [ ]
        for start in sorted(starts.keys()):
            items = starts[start]
            row = [ time_entry(begin + datetime.timedelta(minutes = start), start) ]
            for track in tracks:
                #
                # Start by cleaning out an open sessions that are no longer
                # open at this time.
                # ("sorted" to avoid "dict changed during iteration" errors)
                #
                for opentrack in sorted(openitems.keys()):
                    item = openitems[opentrack]
                    if item.end <= (begin + datetime.timedelta(minutes = start)):
                        del openitems[opentrack]
                #
                # We're starting a new session in this track at this
                # time.
                #
                if track in items:
                    item = items[track]
                    join_button = False
                    if (track not in has_join_button) and (start < 30):
                        join_button = True
                        has_join_button.append(track)
                    row.append(session_entry(item, button = join_button))
                    openitems[track] = item
                    item.rows = 1
                #
                # There is an ongoing session in this track that maybe
                # has ended.
                #
                elif track in openitems:
                    openitems[track].rows += 1
                    row.append(skip_entry())
                #
                # Otherwise nothing happening at all.
                #
                else:
                    row.append(blank_entry())
            rows.append(row)
        return rows

    #
    # Actually generate the table.
    #
    def render_rows [html] (self, begin, minutes, rows):
        '''<p>
           <table class="tt">'''
        nrow = 0
        for row in rows:
            if nrow == 0:
                rowclass = 'class="tthdr"'
            else:
                rowclass = ''
            '<tr %s>' % (rowclass)
            for entry in row:
                entry.render()
            nrow += 1
        '</table>\n'

    #
    # Access to the hack rooms
    #
    @export
    def hackrooms [html] (self):
        #
        # We need a proper _q_access function!
        #
        user = self.logged_in()
        if not user:
            return get_response().redirect(config.SITE_URL)
        page.header('/hackrooms', 'LPC 2020 hackrooms', user.is_admin())
        '''This page lists the LPC 2020 hackrooms â€” rooms that are open for
           informal meetings or just the desire to get together and talk for a
           bit.
           <p>
           Please remember that our code of conduct applies to the hackrooms,
           and that your presence in these rooms will be visible on this page.
           '''
        page.end_text_area()
        '''<p>
           <blockquote>
           <table>
           <tr><th></th><th>Room</th><th>Participants</th></tr>
           '''
        for room in bbb.all_rooms(type = 'hack'):
            status = bbb.room_status(room)
            if status['running']:
                people = status['participants']
            else:
                people = '(empty)'
            '<tr><td>%s</td><td>%s</td><td>%s</td></tr>\n' % (room_join_button(room),
                                                              room, people)
        '</table></blockquote>\n'
        page.trailer()

#
# Button creators outside the class since we use them in the entries
# below as well.
#
def room_start_button [html] (room):
    '''<form action="start_room" method="post">
       <input type="hidden" name="room" value="%s">
       <input type="submit" name="join" class="room"
        value="Start room">
       </form>''' % (room)

def room_join_button [html] (room, button_text = 'Join room'):
    '''<form action="join_room" method="post">
       <input type="hidden" name="room" value="%s">
       <input type="submit" name="join" class="room"
        title="Join room" value="%s">
       </form>''' % (room, button_text)

#
# Simple classes for each of the times of timetable content.
#
class ttentry:
    def __init__(self, title):
        self.title = title

    def render [html] (self): # replace me
        return '   <td>%s</td>\n' % (self.title)

#
# An actual event in the schedule.
#
class session_entry(ttentry):
    def __init__(self, item, button = False):
        ttentry.__init__(self, item.title)
        self.item = item
        self.button = button

    def render [html] (self):
        #
        # Apply a background color if one is available.
        #
        bgcolor = ''
        if self.item.track:
            try:
                bgcolor = 'bgcolor="%s"' % (track_colors[self.item.track])
            except KeyError:
                print('No color: ', self.item.track)
        '<td rowspan=%d valign="top" %s>' % (self.item.rows, bgcolor)
        #
        # Render the title, as a link if we have a URL.
        #
        if self.item.url:
            '''<p class="contributiontitle">
               <a href="%s" title="%s">%s</a></p>
               ''' % (self.item.url, self.item.desc, self.item.title)
        else:
            '<p class="contributiontitle">%s</p>' % (self.item.title)
        if self.item.presenters:
            '<p class="speakers">%s</p>\n' % (', '.join(self.item.presenters))
        '<p class="tttrack">%s</p>\n' % (self.item.track)
        #
        # Room join button
        #
        if self.button:
            room_join_button(self.item.room, 'Join session')
        '</td>\n'

#
# We're not putting anything in this box (skipped due to rowspan=)
#
class skip_entry(ttentry):
    def __init__(self):
        ttentry.__init__(self, 'skip')

    def render [html] (self):
        ''

#
# Nothing to see here, move along.
#
class blank_entry(ttentry):
    def __init__(self):
        ttentry.__init__(self, 'blank')
    def render [html] (self):
        return '<td class="blank"></td>'

#
# Times in the left column.
#
class time_entry(ttentry):
    def __init__(self, time, offset):
        ttentry.__init__(self, 'timestamp')
        self.time = time
        self.offset = offset

    def render [html] (self):
        '   <td valign="top"><b>'
        if self.offset > 10: # Arbitrary
            offset_time(self.time).strftime(str("%H:%M"))
        else:
            '(now)'
        '</b></td>\n'

#
# Room names along the top.
#
class room_entry(ttentry):
    def __init__(self, room):
        ttentry.__init__(self, room)

    def render [html] (self):
        if self.title:
            '<th>' + self.title + '</th>\n'
        else:
            '<td></td>\n'

#
# Crude track-to-color mapping
#
track_colors = { }
def load_track_colors(cdir):
    try:
        with open(cdir + '/tracks', 'r') as f:
            for line in f.readlines():
                line = line.strip()
                if line == '' or line[0] == '#':
                    continue
                sline = line.split(':')
                if len(sline) != 2:
                    print('Bad tracks line: %s' % (line))
                else:
                    track_colors[sline[0]] = sline[1]
    except FileNotFoundError:
        print('Unable to open tracks file')

#
# The login form
#
class LoginForm:
    def __init__(self, email = ''):
        self.email = StringWidget(name="email", size = 30, value = email,
                                  id="loginemail", placeholder="Email address")
        self.pw = PasswordWidget(name = 'Password', size = 30, id="logincode",
                                 placeholder="Registration Confirmation Number")

    def render [html] (self, target):
        '''<form action=%s method="post">
           %s
           %s
           %s
           </form>
           ''' % (target, self.email.render(), self.pw.render(),
                  SubmitWidget(name = 'login', value = 'Log in').render())

    def parse(self):
        return (self.email.parse(), self.pw.parse())

#
# Let's see if we can magically get their timezone offset
#
def insert_tz_js [html] ():
    '''<script type="text/javascript">
       <!--
       function setTZCookie() {
           off = new Date().getTimezoneOffset();
           document.cookie = "tzoffset=" + off + "; SameSite=strict;";
       }
       window.onload = setTZCookie;
       // -->
       </script>
       '''

def user_tz_offset():
    return -int(get_request().get_cookie('tzoffset', '0'))

#
# Shift a datetime from its current zone to our current offset.
#
def offset_time(dt):
    current = dt.tzinfo.utcoffset(dt)
    shift = current - datetime.timedelta(minutes = user_tz_offset())
    return dt - shift

#
# A kludgy time selector to be used before production.
#
weekdays = [ (6, 'Sunday'), (0, 'Monday'), (1, 'Tuesday'), (2, 'Wednesday'),
             (3, 'Thursday'), (4, 'Friday'), (5, 'Saturday') ]

class time_selector_widget:
    def __init__(self, weekday, hour):
        self.wday = SingleSelectWidget(name = 'weekday', value = weekday,
                                       options = weekdays)
        hours = [ (hour, '%d:00' % (hour)) for hour in range(24) ]
        self.hour = SingleSelectWidget(name = 'hour', value = hour,
                                       options = hours)

    def render [html] (self):
        '''<blockquote>
           <form action="fake_time" method="post">
           <table> <!-- dont ask -->
           <tr><td>See schedule at</td><td>%s</td><td>on</td><td>%s.</td>
               <td>%s</td></tr>
           </table>
           </form>
           </blockquote>
           ''' % (self.hour.render(), self.wday.render(),
                  SubmitWidget("Go", "Go").render())

    def parse(self):
        return (int(self.wday.parse()), int(self.hour.parse()))
