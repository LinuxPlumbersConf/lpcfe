from quixote.directory import Directory, export, subdir
from quixote import get_request, get_response
from quixote.form import *
import datetime

import auth, page, bbb, config, indico, timetable, times, buttons

#
# Show this many minutes of upcoming sessions.
#
minutes = 240

class frontend(Directory):

    @export(name='')
    def index [html] (self):
        user = self.logged_in()
        if user:
            self.front_page(user)
        else:
            self.login_form()

    def front_page [html] (self, user):
        page.header('/', 'Welcome %s!' % (user.name), user.is_admin())
        self.main_text()
        page.end_text_area()
        self.render_schedule(times.current_time(), minutes)
        if user.is_admin():
            self.time_selector(times.current_time())
        page.trailer()

    def main_text [html] (self):
        '''This is the entry portal for the Linux Plumbers Conference 2020
           meeting rooms.  Look below for the list of what is happening
           currently.
           <p>
           The timetable below is focused on current (or near-future) sessions.
           Times are given in both UTC and our best guess as to your local time
           (which appears to be offset from UTC by %d minutes).  Click on the
           "join" button that will appear for any sessions that are currently
           ongoing.
           <p>
           The full schedule is always available on the <a
           href="https://linuxplumbersconf.org/event/7/timetable/?view=lpc">main
           Linux Plumbers Conference</a> site.
           <p>
           Thank you for participating in LPC 2020; please do not hesitate to
           contact us at <tt>contact@linuxplumbersconf.org</tt> should you have
           any difficulties, questions, or comments.
           ''' % (times.user_tz_offset(get_request()))

    def time_selector(self, when):
        return time_selector_widget(when.weekday(), when.hour).render()

    @export
    def fake_time [html] (self):
        weekday, hour = time_selector_widget(0, 0).parse()
        page.header('/', 'LPC timetable at a fake time')
        tz = datetime.timezone(datetime.timedelta(hours = config.SERVER_TZOFFSET))
        begin = datetime.datetime(2020, 8, 24, 0, 0, 0, tzinfo = tz)
        begin += datetime.timedelta(days = weekday)
        begin += datetime.timedelta(hours = hour)
        '''This is the timetable rendered as if it were %s on the server.
        ''' % (begin.strftime(str('%Y-%m-%d %H:%M')))
        page.end_text_area()
        self.render_schedule(begin, minutes)
        self.time_selector(begin)
        page.trailer()


    @export
    def logout(self):
        response = get_response()
        response.expire_cookie('session')
        return response.redirect(config.SITE_URL)

    @export
    def stylesheet(self):
        response = get_response()
        response.set_header('content-type', 'text/css; charset=utf-8')
        response.cache = 600
        return page.CSS()
    #
    # Return the logged-in user, if any.
    #
    def logged_in(self):
        request = get_request()
        cookie = request.get_cookie('session')
        if not cookie:
            return None
        return auth.validate_cookie(cookie)

    def login_form [html] (self, message = None, email = ''):
        page.header('/', 'Please log in to continue', menu = False)
        insert_tz_js()
        '''Please login with the email address you used to register to LPC 2020.
           You need to enter your Registration Confirmation Number. That
           information is found in your confirmation email titled
           "Registration Confirmed - Linux Plumbers Conference 2020".
           <p>
           '''
        if message:
            '<b>' + message + '</b><p>\n'
        '<blockquote>\n'
        LoginForm(email = email).render('/login')
        '</blockquote>\n'
        '''<h4>Having trouble?</h4>
           <p>
           Please contact <tt>helpdesk@linuxplumbersconf.org</tt> for assistance
           accessing the conference site.
           '''
        page.trailer()

    @export
    def login (self):
        email, password = LoginForm().parse()
        if not (email and password):
            return self.login_form('Please fill in both fields', email = email)
        u = auth.check_password(email, password)
        if not u:
            return self.login_form('Unknown email or invalid password',
                                   email = email)
        #
        # OK, they've convinced us that they are for real.  Let's fix
        # them up with a session cookie and give them the real page.
        #
        cookie = auth.make_cookie(u)
        response = get_response()
        response.set_cookie('session', cookie)
        return response.redirect(config.SITE_URL)

    #
    # Moderator's server information page.
    #
    @export
    def status [html] (self):
        user = self.logged_in()
        if (not user) or (not user.is_admin()):
            get_response().redirect(config.SITE_URL)
        page.header('/status', 'Server and room status', True)
        self.list_servers()
        '<br clear="all">\n'
        self.list_rooms()
        page.trailer()

    def list_servers [html] (self):
        '<h4>Server status</h4>'
        '<dl>\n'
        '''<blockquote>
           <table class="OddEven">
           <tr><th>Server</th><th>status</th><th>Rooms</th><th>People</th></tr>
           '''
        for server in bbb.all_servers():
            meetings = bbb.status(server)
            if meetings is None:
                '<tr><td>%s</td><td>DOWN</td><td></td><td></td></tr>\n' % (server)
                continue
            nrooms = len(meetings)
            npeople = 0
            for m in meetings:
                npeople += int(m['people'])
            '<tr><td>%s</td><td>UP</td><td>%d</td><td>%d</td></tr>\n' % \
                        (server, nrooms, npeople)
        '</table></blockquote>\n'
    #
    # Room management
    #
    def list_rooms [html] (self):
        '''<h4>Room status</h4>
           <p>
           <blockquote>
           <table class="OddEven">
           <tr><th>Room</th>
               <th>Server</th>
               <th>Type</th>
               <th>Status</th>
               <th>People</th>
               <th>Listen</th>
               <th>Video</th>
               <th>Moderators</th>
               <th></th></tr>
           '''
        for room in bbb.all_rooms():
            status = bbb.room_status(room)
            '<tr><td>%s</td><td>%s</td><td>%s</td>' % (room, status['server'],
                                                       status['type'])
            if status['running']:
                '''<td>RUNNING</td>
                   <td align=right>%s</td><td align=right>%s</td>
                   <td align=right>%s</td>
                   <td>%s</td><td>''' % (status['people'], status['listeners'],
                                         status['video'], status['moderators'])
                buttons.room_join_button(room)
                '</td></tr>\n'
            else:
                '''<td>CLOSED</td>
                   <td></td><td></td><td></td><td></td><td>'''
                buttons.room_start_button(room)
                '</td></tr>\n'
        '</table></blockquote>\n'

    # Note this isn't currently used
    @export
    def start_room(self):
        response = get_response()
        user = self.logged_in()
        if (not user) or (not user.is_moderator()):
            return response.redirect(config.SITE_URL)
        room = HiddenWidget('room', '').parse()
        bbb.start_room(room)
        url = bbb.join_room_url(user.name, room, user.is_moderator())
        return response.redirect(url)

    @export
    def join_room(self):
        response = get_response()
        user = self.logged_in()
        if not user:
            return response.redirect(config.SITE_URL) # No fast ones here
        room = HiddenWidget('room', '').parse()
        status = bbb.room_status(room)
        #
        # Policy: let any user start a room if they have access to
        # a "join" button.
        #
        if not status['running']:
            bbb.start_room(room)
#            return self.room_closed(room)
        url = bbb.join_room_url(user.name, room, user.is_moderator())
        return response.redirect(url)

    #
    # This is not currently used.
    #
    def room_closed [html] (self, room):
        page.header('/', 'Room closed', False)
        '''The room you are trying to join has not yet been opened for
           general access.  Please accept our apologies for the inconvenience
           and retry shortly.
           <p>
           <blockquote>
           '''
        buttons.room_join_button(room, button_text = 'Retry room ' + room)
        '</blockquote>\n'
    #
    # A first shot at rendering a schedule.
    #
    def render_schedule [html] (self, begin, minutes):
        ttable = indico.get_timetable(begin, minutes)
        #
        # No timetable, figure out something to do.
        #
        if len(ttable) == 0:
            '''<p>
               <b>NOTE</b>: there are no sessions underway at the current
               time.
               '''
            restart = indico.find_restart_time(begin)
            if not restart:
                'In fact, the event appears to be over.\n'
                return
            lrestart = times.offset_time(get_request(), restart)
            '''The conference will restart at %s UTC (%s local) with the sessions
               shown below.
               ''' % (times.utc_time(restart).strftime(str('%Y-%m-%d %H:%M')),
                      lrestart.strftime(str('%H:%M')))
            ttable = indico.get_timetable(restart, minutes)
            #
            # Hack: back up the "start" time by 30 minutes to ensure that
            # the timetable code knows this isn't happening now.
            #
            begin = restart - datetime.timedelta(minutes = 30)
        tracks = sorted(ttable.keys())
        rows = timetable.generate_rows(ttable, tracks, begin)
        timetable.render_rows(begin, rows)


    #
    # Access to the hack rooms
    #
    @export
    def hackrooms [html] (self):
        #
        # We need a proper _q_access function!
        #
        user = self.logged_in()
        if not user:
            return get_response().redirect(config.SITE_URL)
        page.header('/hackrooms', 'LPC 2020 hackrooms', user.is_admin())
        '''This page lists the LPC 2020 hackrooms — rooms that are open for
           informal meetings or just the desire to get together and talk for a
           bit.
           <p>
           Please remember that our code of conduct applies to the hackrooms,
           and that your presence in these rooms will be visible on this page.
           '''
        page.end_text_area()
        '''<p>
           <blockquote>
           <table>
           <tr><th></th><th>Room</th><th>Participants</th></tr>
           '''
        for room in bbb.all_rooms(type = 'hack'):
            status = bbb.room_status(room)
            if status['running']:
                people = status['participants']
            else:
                people = '(empty)'
            '<tr><td>%s</td><td>%s</td><td>%s</td></tr>\n' % (buttons.room_join_button(room),
                                                              room, people)
        '</table></blockquote>\n'
        page.trailer()


#
# The login form
#
class LoginForm:
    def __init__(self, email = ''):
        self.email = StringWidget(name="email", size = 30, value = email,
                                  id="loginemail", placeholder="Email address")
        self.pw = PasswordWidget(name = 'Password', size = 30, id="logincode",
                                 placeholder="Registration Confirmation Number")

    def render [html] (self, target):
        '''<form action=%s method="post">
           %s
           %s
           %s
           </form>
           ''' % (target, self.email.render(), self.pw.render(),
                  SubmitWidget(name = 'login', value = 'Log in').render())

    def parse(self):
        return (self.email.parse(), self.pw.parse())

#
# Let's see if we can magically get their timezone offset
#
def insert_tz_js [html] ():
    '''<script type="text/javascript">
       <!--
       function setTZCookie() {
           off = new Date().getTimezoneOffset();
           document.cookie = "tzoffset=" + off + "; SameSite=strict;";
       }
       window.onload = setTZCookie;
       // -->
       </script>
       '''


#
# A kludgy time selector to be used before production.
#
weekdays = [ (6, 'Sunday'), (0, 'Monday'), (1, 'Tuesday'), (2, 'Wednesday'),
             (3, 'Thursday'), (4, 'Friday'), (5, 'Saturday') ]

class time_selector_widget:
    def __init__(self, weekday, hour):
        self.wday = SingleSelectWidget(name = 'weekday', value = weekday,
                                       options = weekdays)
        hours = [ (hour, '%d:00' % (hour)) for hour in range(24) ]
        self.hour = SingleSelectWidget(name = 'hour', value = hour,
                                       options = hours)

    def render [html] (self):
        '''<blockquote>
           <form action="fake_time" method="post">
           <table> <!-- dont ask -->
           <tr><td>See schedule at</td><td>%s</td><td>on</td><td>%s.</td>
               <td>%s</td></tr>
           </table>
           </form>
           </blockquote>
           ''' % (self.hour.render(), self.wday.render(),
                  SubmitWidget("Go", "Go").render())

    def parse(self):
        return (int(self.wday.parse()), int(self.hour.parse()))
